generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

/**
 * ===== Новые типы =====
 */
enum TaskAssigneeStatus {
  in_progress
  submitted
  done
  rejected
}

/**
 * ===== Пользователи и общие сущности =====
 */
model User {
  id               String    @id @default(uuid())
  name             String
  username         String?   @unique
  email            String?   @unique
  phone            String?   @unique
  birthday         DateTime?
  classroom        String?
  role             String?
  avatarUrl        String?
  telegram         String?
  about            String?
  notifyEmail      Boolean   @default(true)
  notifyTelegram   Boolean   @default(false)
  subjects         String?
  methodicalGroups String?
  passwordHash     String?
  lastSeen         DateTime?

  messages           Message[]       @relation("UserMessages")
  threadsA           Thread[]        @relation("ThreadA")
  threadsB           Thread[]        @relation("ThreadB")
  readMarks          ReadMark[]      @relation("ReadMarkUser")
  groupMemberships   GroupMember[]
  taskAssignments    TaskAssignee[]
  subjectMemberships SubjectMember[]
  createdTasks       Task[]          @relation("TaskCreatedBy")
  messageHides       MessageHide[]

  notes Note[]

  reviewedAssignments TaskAssignee[] @relation("TaskReviewedBy")
  reviewedSubmissions Submission[]   @relation("SubmissionReviewedBy")

  // Новые бэк-связи для заявок
  requestsAuthored   Request[]            @relation("RequestAuthor")
  requestsProcessed  Request[]            @relation("RequestProcessedBy")
  RequestMessage     RequestMessage[]
  DiscussionPost     DiscussionPost[]
  DiscussionComment  DiscussionComment[]
  DiscussionReaction DiscussionReaction[]
}

model Group {
  id      String        @id @default(uuid())
  name    String
  members GroupMember[]
}

model GroupMember {
  id      String @id @default(uuid())
  userId  String
  groupId String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  group   Group  @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
}

model Thread {
  id              String    @id @default(uuid())
  aId             String
  bId             String
  lastMessageAt   DateTime?
  lastMessageText String?
  title           String    @default("")

  a User @relation("ThreadA", fields: [aId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  b User @relation("ThreadB", fields: [bId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  messages  Message[]
  readMarks ReadMark[] @relation("ReadMarkThread")

  @@index([lastMessageAt, id])
}

model Message {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  text      String
  authorId  String
  threadId  String

  editedAt  DateTime?
  deletedAt DateTime?

  author User   @relation("UserMessages", fields: [authorId], references: [id], onDelete: Cascade)
  thread Thread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  attachments Attachment[]  @relation("MessageAttachments")
  hides       MessageHide[]

  @@index([threadId, createdAt])
}

model MessageHide {
  messageId String
  userId    String

  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId])
  @@index([userId])
}

/**
 * ===== Задачи и исполнители =====
 */
model Task {
  id          String   @id @default(uuid())
  title       String
  description String
  dueDate     DateTime
  hidden      Boolean  @default(false)
  priority    String   @default("normal")

  createdAt     DateTime @default(now())
  updatedAt     DateTime @default(now()) @updatedAt
  createdById   String?
  createdByName String?

  reviewRequired Boolean @default(false)

  createdBy User? @relation("TaskCreatedBy", fields: [createdById], references: [id], onDelete: SetNull, onUpdate: Cascade)

  assignees TaskAssignee[]
  tags      TaskTag[]

  // НОВОЕ:
  number      Int              @unique @default(autoincrement())
  attachments TaskAttachment[]

  @@index([createdById])
  @@index([dueDate])
}

model TaskAssignee {
  id     String @id @default(uuid())
  taskId String
  userId String
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  status      TaskAssigneeStatus @default(in_progress)
  assignedAt  DateTime           @default(now())
  completedAt DateTime?

  submittedAt  DateTime?
  reviewedAt   DateTime?
  reviewedById String?
  reviewedBy   User?     @relation("TaskReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)

  submissions Submission[]

  @@unique([taskId, userId])
  @@index([userId])
  @@index([taskId])
  @@index([status])
  @@index([reviewedById])
}

model Tag {
  id    String    @id @default(uuid())
  name  String    @unique
  tasks TaskTag[]
}

model TaskTag {
  id     String @id @default(uuid())
  taskId String
  tagId  String
  task   Task   @relation(fields: [taskId], references: [id])
  tag    Tag    @relation(fields: [tagId], references: [id])
}

/**
 * ===== Read marks =====
 */
model ReadMark {
  threadId String
  userId   String
  readAt   DateTime

  thread Thread @relation("ReadMarkThread", fields: [threadId], references: [id], onDelete: Cascade)
  user   User   @relation("ReadMarkUser", fields: [userId], references: [id], onDelete: Cascade)

  @@id([threadId, userId])
  @@index([userId])
}

/**
 * ===== Файлы =====
 */
model Attachment {
  id        String   @id @default(uuid())
  messageId String?
  message   Message? @relation("MessageAttachments", fields: [messageId], references: [id], onDelete: Cascade)

  name         String
  originalName String?
  mime         String
  size         Int
  data         Bytes?
  sha256       String?  @db.VarChar(64)
  createdAt    DateTime @default(now())

  submissionLinks SubmissionAttachment[]

  // НОВОЕ:
  taskLinks                   TaskAttachment[]
  DiscussionPostAttachment    DiscussionPostAttachment[]
  DiscussionCommentAttachment DiscussionCommentAttachment[]

  @@index([messageId])
}

/**
 * новая сущность
 */
model TaskAttachment {
  taskId       String
  attachmentId String

  task       Task       @relation(fields: [taskId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  attachment Attachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([taskId, attachmentId])
  @@index([attachmentId])
}

/**
 * ===== Нормализованные предметы =====
 */
model Subject {
  id      String          @id @default(uuid())
  name    String          @unique
  members SubjectMember[]
}

model SubjectMember {
  id        String  @id @default(uuid())
  userId    String
  subjectId String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  subject   Subject @relation(fields: [subjectId], references: [id], onDelete: Cascade)

  @@unique([userId, subjectId])
}

/**
 * ===== Заметки =====
 */
model Note {
  id        String   @id @default(uuid())
  userId    String
  at        DateTime
  allDay    Boolean  @default(true)
  title     String?
  text      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, at])
  @@index([at])
}

/**
 * ===== Новые сущности review-flow =====
 */
model Submission {
  id             String   @id @default(uuid())
  taskAssigneeId String
  comment        String?
  createdAt      DateTime @default(now())

  open            Boolean   @default(true)
  reviewedAt      DateTime?
  reviewedById    String?
  reviewerComment String?

  reviewedBy  User?                  @relation("SubmissionReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)
  assignee    TaskAssignee           @relation(fields: [taskAssigneeId], references: [id], onDelete: Cascade)
  attachments SubmissionAttachment[]

  @@index([taskAssigneeId])
  @@index([reviewedById])
  @@index([taskAssigneeId, open])
}

model SubmissionAttachment {
  submissionId String
  attachmentId String

  submission Submission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  attachment Attachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@id([submissionId, attachmentId])
  @@index([attachmentId])
}

/**
 * ===== Requests (заявки) =====
 */
enum RequestStatus {
  new
  in_progress
  done
  rejected
}

model Request {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorId String
  author   User   @relation("RequestAuthor", fields: [authorId], references: [id], onDelete: Cascade)

  target String
  status RequestStatus @default(new)

  title String
  body  String

  processedById String?
  processedBy   User?   @relation("RequestProcessedBy", fields: [processedById], references: [id], onDelete: SetNull)

  closedAt       DateTime?
  rejectedReason String?
  lastMessageAt  DateTime @default(now())

  globalNumber Int  @unique @default(autoincrement())
  targetNumber Int?

  messages RequestMessage[]

  @@unique([target, targetNumber])
  @@index([authorId, status, lastMessageAt])
  @@index([target, status, lastMessageAt])
  @@index([target, targetNumber])
}


model RequestMessage {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  requestId String
  authorId  String
  body      String

  request Request @relation(fields: [requestId], references: [id], onDelete: Cascade)
  author  User    @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([requestId, createdAt])
}

/**
 * Служебный счётчик по адресату (строка-ключ = target)
 */
model RequestCounter {
  target     String @id // например, "sysadmin", "ahch"
  lastNumber Int    @default(0)
}

/**
 * ===== Discussions (объявления и обсуждения) =====
 */
model DiscussionPost {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  authorId String
  text     String
  pinned   Boolean @default(false)

  author                   User                       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  comments                 DiscussionComment[]
  reactions                DiscussionReaction[]
  DiscussionPostAttachment DiscussionPostAttachment[]

  @@index([createdAt])
}

model DiscussionComment {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  postId   String
  authorId String
  text     String

  post                        DiscussionPost                @relation(fields: [postId], references: [id], onDelete: Cascade)
  author                      User                          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  DiscussionCommentAttachment DiscussionCommentAttachment[]

  @@index([postId, createdAt])
}

/**
 * одна реакция "like" на пользователя; тип — строкой на будущее
 */
model DiscussionReaction {
  postId String
  userId String
  kind   String @default("like")

  post DiscussionPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([postId, userId])
}

/**
 * Опционально: связь с существующим Attachment (UI можно не включать сразу)
 */
model DiscussionPostAttachment {
  postId       String
  attachmentId String

  post       DiscussionPost @relation(fields: [postId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  attachment Attachment     @relation(fields: [attachmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([postId, attachmentId])
  @@index([attachmentId])
}

model DiscussionCommentAttachment {
  commentId    String
  attachmentId String

  comment    DiscussionComment @relation(fields: [commentId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  attachment Attachment        @relation(fields: [attachmentId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@id([commentId, attachmentId])
  @@index([attachmentId])
}
